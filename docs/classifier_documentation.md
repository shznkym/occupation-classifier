# classifier.py å®Œå…¨è§£èª¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

## ğŸ“„ æ¦‚è¦

`classifier.py`ã¯è·æ¥­åˆ†é¡åˆ¤å®šã‚·ã‚¹ãƒ†ãƒ ã®**æ ¸å¿ƒéƒ¨åˆ†**ã§ã€RAGï¼ˆRetrieval-Augmented Generationï¼‰ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚

**ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±:**
- ãƒ‘ã‚¹: `backend/app/classifier.py`
- è¡Œæ•°: 365è¡Œ
- ä¸»è¦ã‚¯ãƒ©ã‚¹: `OccupationClassifier`
- ä¾å­˜é–¢ä¿‚: Gemini API, pandas, numpy, scikit-learn

---

## ğŸ—ï¸ ã‚¯ãƒ©ã‚¹æ§‹é€ 

### OccupationClassifier ã‚¯ãƒ©ã‚¹

```python
class OccupationClassifier:
    """
    è·æ¥­åˆ†é¡åˆ¤å®šã‚¯ãƒ©ã‚¹ï¼ˆRAGã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…ï¼‰
    
    ç‰¹å¾´:
    - ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯1ã¤ã ã‘ï¼‰
    - Gemini Embedding API ã§æ„å‘³çš„æ¤œç´¢
    - Gemini Generative API ã§æœ€çµ‚åˆ¤å®š
    - Embeddingã‚­ãƒ£ãƒƒã‚·ãƒ¥ã§é«˜é€ŸåŒ–
    """
```

**ä¸»è¦ãªå±æ€§:**
```python
self.api_key            # Gemini APIã‚­ãƒ¼
self.embedding_model    # "models/text-embedding-004"
self.llm_model          # "models/gemini-2.5-flash"
self.model              # GenerativeModelã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
self.data               # è·æ¥­ãƒ‡ãƒ¼ã‚¿ï¼ˆDataFrameï¼‰
self.embeddings         # è·æ¥­ãƒ‡ãƒ¼ã‚¿ã®Embeddingï¼ˆnumpyé…åˆ—ï¼‰
self.embedding_texts    # Embeddingå¯¾è±¡ã®ãƒ†ã‚­ã‚¹ãƒˆãƒªã‚¹ãƒˆ
```

---

## ğŸ“‹ ãƒ¡ã‚½ãƒƒãƒ‰è©³ç´°

### 1. `__new__` - ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè£…

**ã‚³ãƒ¼ãƒ‰:**
```python
_instance = None

def __new__(cls, *args, **kwargs):
    """ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè£…"""
    if cls._instance is None:
        cls._instance = super().__new__(cls)
    return cls._instance
```

**ç›®çš„:**
- ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã§1ã¤ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã¿ã‚’ä½¿ç”¨
- ãƒ¡ãƒ¢ãƒªåŠ¹ç‡åŒ–ï¼ˆ415ä»¶ã®Embeddingã‚’1å›ã ã‘ä¿æŒï¼‰

**å‹•ä½œ:**
```python
# è¤‡æ•°å›ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã—ã¦ã‚‚åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™
classifier1 = OccupationClassifier()  # æ–°è¦ä½œæˆ
classifier2 = OccupationClassifier()  # åŒã˜ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
print(classifier1 is classifier2)      # True
```

**ãªãœå¿…è¦ï¼Ÿ**
- FastAPIã¯è¤‡æ•°ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’èµ·å‹•ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
- å„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã§æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ã¨ã€ãƒ¡ãƒ¢ãƒªã¨APIå‘¼ã³å‡ºã—ãŒç„¡é§„
- 1ã¤ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…±æœ‰ã™ã‚‹ã“ã¨ã§åŠ¹ç‡åŒ–

---

### 2. `__init__` - åˆæœŸåŒ–å‡¦ç†

**ã‚·ã‚°ãƒãƒãƒ£:**
```python
def __init__(self, csv_path: str = None, api_key: str = None):
```

**ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:**
| ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ | å‹ | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜ |
|-----------|-----|-----------|------|
| `csv_path` | str | None | è·æ¥­ãƒ‡ãƒ¼ã‚¿CSVã®ãƒ‘ã‚¹ |
| `api_key` | str | None | Gemini APIã‚­ãƒ¼ |

**å‡¦ç†ãƒ•ãƒ­ãƒ¼:**

```mermaid
graph TB
    A[__init__å‘¼ã³å‡ºã—] --> B{æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿?}
    B -->|Yes| C[ã‚¹ã‚­ãƒƒãƒ—]
    B -->|No| D[APIã‚­ãƒ¼å–å¾—]
    D --> E{APIã‚­ãƒ¼æœ‰åŠ¹?}
    E -->|No| F[ValueErrorç™ºç”Ÿ]
    E -->|Yes| G[Gemini APIè¨­å®š]
    G --> H[ãƒ¢ãƒ‡ãƒ«æŒ‡å®š]
    H --> I[ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰]
    I --> J[Embeddingså¤‰æ•°åˆæœŸåŒ–]
    J --> K[åˆæœŸåŒ–å®Œäº†ãƒ•ãƒ©ã‚°]
```

**è©³ç´°ã‚³ãƒ¼ãƒ‰è§£èª¬:**

```python
# 1. æ—¢å­˜ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å†åˆ©ç”¨æ™‚ã®ã‚¹ã‚­ãƒƒãƒ—
if hasattr(self, '_initialized'):
    return  # 2å›ç›®ä»¥é™ã¯ä½•ã‚‚ã—ãªã„

# 2. APIã‚­ãƒ¼å–å¾—ï¼ˆå„ªå…ˆé †ä½: å¼•æ•° > ç’°å¢ƒå¤‰æ•°ï¼‰
self.api_key = api_key or os.getenv("GEMINI_API_KEY")

# 3. APIã‚­ãƒ¼æ¤œè¨¼
if not self.api_key or self.api_key == "your_gemini_api_key_here":
    raise ValueError("GEMINI_API_KEYãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚")

# 4. Gemini APIè¨­å®š
genai.configure(api_key=self.api_key)

# 5. ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
self.embedding_model = "models/text-embedding-004"  # ãƒ™ã‚¯ãƒˆãƒ«åŒ–ç”¨
self.llm_model = "models/gemini-2.5-flash"          # æ¨è«–ç”¨

# 6. GenerativeModelã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆ
self.model = genai.GenerativeModel(self.llm_model)

# 7. ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰
self.data = self._load_data(csv_path)

# 8. Embeddingsï¼ˆé…å»¶è©•ä¾¡ - å¾Œã§ä½œæˆï¼‰
self.embeddings = None
self.embedding_texts = None

# 9. åˆæœŸåŒ–å®Œäº†
self._initialized = True
print(f"OccupationClassifier initialized with {len(self.data)} occupations")
```

---

### 3. `_load_data` - ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿

**ã‚·ã‚°ãƒãƒãƒ£:**
```python
def _load_data(self, csv_path: str = None) -> pd.DataFrame:
```

**å‡¦ç†ãƒ•ãƒ­ãƒ¼:**

```python
def _load_data(self, csv_path: str = None):
    """
    ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ï¼ˆå„ªå…ˆé †ä½ä»˜ãï¼‰
    
    1. csv_pathãŒæŒ‡å®š & ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ â†’ CSVã‹ã‚‰èª­ã¿è¾¼ã¿ï¼ˆå®Ÿãƒ‡ãƒ¼ã‚¿ï¼‰
    2. ãã‚Œä»¥å¤– â†’ ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ä½œæˆï¼ˆ16è·æ¥­ï¼‰
    """
    
    # ã‚±ãƒ¼ã‚¹1: CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿
    if csv_path and os.path.exists(csv_path):
        print(f"CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™: {csv_path}")
        return pd.read_csv(csv_path)
    
    # ã‚±ãƒ¼ã‚¹2: ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ä½œæˆï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    else:
        print("ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™...")
        dummy_data = [
            # 16è·æ¥­ã®ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿
            {...}, {...}, ...
        ]
        return pd.DataFrame(dummy_data)
```

**ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã®è©³ç´°:**

ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã¯**16è·æ¥­**ã§æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ï¼š

| ã‚³ãƒ¼ãƒ‰ | è·æ¥­å | èª¬æ˜ |
|-------|-------|------|
| 11 | ç®¡ç†çš„è·æ¥­å¾“äº‹è€… | ä¼šç¤¾å½¹å“¡ã€ä¼æ¥­ã®éƒ¨èª²é•·... |
| 21 | ä¸€èˆ¬äº‹å‹™å¾“äº‹è€… | åº¶å‹™ã€äººäº‹ã€çµŒç†... |
| 25 | ä¼šè¨ˆäº‹å‹™å¾“äº‹è€… | çµŒç†æ‹…å½“è€…ã€ä¼šè¨ˆä¿‚... |
| 32 | ä¿å®‰è·æ¥­å¾“äº‹è€… | è‡ªè¡›å®˜ã€è­¦å¯Ÿå®˜ã€æ¶ˆé˜²å£«... |
| 35 | ä»‹è­·ã‚µãƒ¼ãƒ“ã‚¹è·æ¥­å¾“äº‹è€… | ä»‹è­·ç¦ç¥‰å£«ã€ãƒ˜ãƒ«ãƒ‘ãƒ¼... |
| 41 | è²©å£²å¾“äº‹è€… | å°å£²åº—å“¡ã€å–¶æ¥­è·... |
| 52 | é£²é£Ÿç‰©èª¿ç†å¾“äº‹è€… | èª¿ç†å¸«ã€ã‚³ãƒƒã‚¯... |
| 61 | è¾²æ—æ¼æ¥­å¾“äº‹è€… | è¾²å®¶ã€æ¼å¸«... |
| 71 | è£½é€ ãƒ»åŠ å·¥å‡¦ç†å¾“äº‹è€… | å·¥å ´ä½œæ¥­å“¡... |
| 81 | å»ºè¨­ãƒ»æ¡æ˜å¾“äº‹è€… | å¤§å·¥ã€å»ºç¯‰ä½œæ¥­å“¡... |
| 91 | é‹æ¬ãƒ»æ¸…æƒãƒ»åŒ…è£…ç­‰å¾“äº‹è€… | ãƒˆãƒ©ãƒƒã‚¯é‹è»¢æ‰‹... |
| 12 | æƒ…å ±å‡¦ç†ãƒ»é€šä¿¡æŠ€è¡“è€… | SEã€ãƒ—ãƒ­ã‚°ãƒ©ãƒãƒ¼... |
| 14 | å»ºç¯‰ãƒ»åœŸæœ¨ãƒ»æ¸¬é‡æŠ€è¡“è€… | å»ºç¯‰å£«ã€åœŸæœ¨æŠ€è¡“è€…... |
| 15 | åŒ»å¸«ãƒ»æ­¯ç§‘åŒ»å¸«ãƒ»ç£åŒ»å¸«ãƒ»è–¬å‰¤å¸« | åŒ»å¸«ã€æ­¯ç§‘åŒ»... |
| 16 | ä¿å¥å¸«ãƒ»åŠ©ç”£å¸«ãƒ»çœ‹è­·å¸« | çœ‹è­·å¸«ã€ä¿å¥å¸«... |
| 17 | æ•™å“¡ | å°å­¦æ ¡æ•™å“¡ã€ä¸­å­¦æ ¡æ•™å“¡... |

**ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã®å½¹å‰²:**

1. **é–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆç’°å¢ƒ**: CSVãƒ•ã‚¡ã‚¤ãƒ«ãªã—ã§å‹•ä½œç¢ºèª
2. **ãƒ‡ãƒ¢ç”¨**: APIåˆ¶é™ãŒã‚ã£ã¦ã‚‚ãƒ‡ãƒ¢å®Ÿè¡Œå¯èƒ½
3. **ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯**: ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®ä¿é™º

**ç¾åœ¨ã®é‹ç”¨çŠ¶æ…‹:**

```python
# main.py ã§ã®å‘¼ã³å‡ºã—
classifier = OccupationClassifier(csv_path="data/occupation.csv")

çµæœ:
â†’ CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨: âœ…
â†’ å®Ÿãƒ‡ãƒ¼ã‚¿415ä»¶ã‚’èª­ã¿è¾¼ã¿
â†’ ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã¯ä½¿ç”¨ã—ãªã„
```

---

### 4. `create_embeddings` - Embeddingä½œæˆï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½ä»˜ãï¼‰

**ã‚·ã‚°ãƒãƒãƒ£:**
```python
def create_embeddings(self, force_recreate: bool = False):
```

**ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:**
| ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ | å‹ | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜ |
|-----------|-----|-----------|------|
| `force_recreate` | bool | False | ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡è¦–ã—ã¦å†ä½œæˆ |

**å‡¦ç†ãƒ•ãƒ­ãƒ¼:**

```mermaid
graph TB
    A[create_embeddingså‘¼ã³å‡ºã—] --> B{force_recreate?}
    B -->|False| C{ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚ã‚Š?}
    B -->|True| G
    
    C -->|Yes| D[ã‚­ãƒ£ãƒƒã‚·ãƒ¥èª­ã¿è¾¼ã¿]
    D --> E[APIå‘¼ã³å‡ºã—ã‚¼ãƒ­!]
    E --> F[å®Œäº†]
    
    C -->|No| G[Embeddingä½œæˆ]
    G --> H[415å›APIå‘¼ã³å‡ºã—]
    H --> I[numpyé…åˆ—åŒ–]
    I --> J[ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜]
    J --> F
```

**è©³ç´°ã‚³ãƒ¼ãƒ‰:**

```python
def create_embeddings(self, force_recreate: bool = False):
    cache_file = "data/embeddings_cache.npy"
    
    # ã‚¹ãƒ†ãƒƒãƒ—1: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰èª­ã¿è¾¼ã¿ï¼ˆé«˜é€ŸåŒ–ï¼‰
    if not force_recreate and os.path.exists(cache_file):
        try:
            print(f"ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰Embeddingsã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™: {cache_file}")
            self.embeddings = np.load(cache_file)
            
            # embedding_textsã‚‚å†æ§‹ç¯‰
            self.embedding_texts = (
                self.data['name'] + 'ã€‚' + self.data['description']
            ).tolist()
            
            print(f"Embeddingsã‚­ãƒ£ãƒƒã‚·ãƒ¥èª­ã¿è¾¼ã¿å®Œäº† (shape: {self.embeddings.shape})")
            print(f"ğŸ’¡ APIå‘¼ã³å‡ºã—ã‚’ç¯€ç´„ã—ã¾ã—ãŸï¼ï¼ˆ{len(self.data)}ä»¶ã®Embeddingä½œæˆã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼‰")
            return
            
        except Exception as e:
            print(f"âš ï¸ ã‚­ãƒ£ãƒƒã‚·ãƒ¥èª­ã¿è¾¼ã¿å¤±æ•—: {e}")
            print("æ–°ã—ãEmbeddingsã‚’ä½œæˆã—ã¾ã™...")
    
    # ã‚¹ãƒ†ãƒƒãƒ—2: æ—¢ã«ä½œæˆæ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
    if self.embeddings is not None:
        print("Embeddingsã¯æ—¢ã«ä½œæˆæ¸ˆã¿ã§ã™")
        return
    
    # ã‚¹ãƒ†ãƒƒãƒ—3: Embeddingä½œæˆï¼ˆæ™‚é–“ãŒã‹ã‹ã‚‹ï¼‰
    print(f"Embeddingsã‚’ä½œæˆã—ã¦ã„ã¾ã™...ï¼ˆ{len(self.data)}ä»¶ï¼‰")
    print("âš ï¸ åˆå›ã®ã¿æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™ã€‚æ¬¡å›ã‹ã‚‰ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
    
    # ãƒ†ã‚­ã‚¹ãƒˆçµåˆ: "è·æ¥­åã€‚èª¬æ˜æ–‡"
    self.embedding_texts = (
        self.data['name'] + 'ã€‚' + self.data['description']
    ).tolist()
    
    # Gemini Embedding APIå‘¼ã³å‡ºã—
    embeddings_list = []
    for i, text in enumerate(self.embedding_texts):
        if (i + 1) % 50 == 0:
            print(f"  é€²æ—: {i + 1}/{len(self.embedding_texts)}")
        
        try:
            result = genai.embed_content(
                model=self.embedding_model,  # "models/text-embedding-004"
                content=text
            )
            embeddings_list.append(result['embedding'])
        except Exception as e:
            print(f"  ã‚¨ãƒ©ãƒ¼ (è·æ¥­ {i}): {e}")
            raise
    
    # numpyé…åˆ—ã«å¤‰æ›
    self.embeddings = np.array(embeddings_list)
    print(f"Embeddingsä½œæˆå®Œäº† (shape: {self.embeddings.shape})")
    
    # ã‚¹ãƒ†ãƒƒãƒ—4: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
    try:
        os.makedirs(os.path.dirname(cache_file), exist_ok=True)
        np.save(cache_file, self.embeddings)
        print(f"âœ… Embeddingsã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜ã—ã¾ã—ãŸ: {cache_file}")
        print(f"ğŸ’¡ æ¬¡å›èµ·å‹•æ™‚ã¯APIå‘¼ã³å‡ºã—ãªã—ã§é«˜é€Ÿèµ·å‹•ã§ãã¾ã™ï¼")
    except Exception as e:
        print(f"âš ï¸ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜å¤±æ•—ï¼ˆç„¡è¦–ã—ã¦ç¶šè¡Œï¼‰: {e}")
```

**ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ•ã‚¡ã‚¤ãƒ«:**
- ãƒ‘ã‚¹: `data/embeddings_cache.npy`
- ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ: NumPy binary format
- ã‚µã‚¤ã‚º: ç´„1.3MBï¼ˆ415 Ã— 768 Ã— 4bytesï¼‰

**APIå‘¼ã³å‡ºã—ã®å‰Šæ¸›åŠ¹æœ:**

| ã‚·ãƒŠãƒªã‚ª | APIå‘¼ã³å‡ºã—æ•° |
|---------|-------------|
| åˆå›èµ·å‹•ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ãªã—ï¼‰ | 415å› |
| 2å›ç›®ä»¥é™ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚ã‚Šï¼‰ | **0å›** ğŸ‰ |

---

### 5. `search_candidates` - é¡ä¼¼è·æ¥­æ¤œç´¢

**ã‚·ã‚°ãƒãƒãƒ£:**
```python
def search_candidates(self, user_input: str, top_k: int = 5) -> List[Dict]:
```

**ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:**
| ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ | å‹ | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜ |
|-----------|-----|-----------|------|
| `user_input` | str | - | ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è‡ªç”±è¨˜è¿°å…¥åŠ› |
| `top_k` | int | 5 | å–å¾—ã™ã‚‹å€™è£œæ•° |

**æˆ»ã‚Šå€¤:**
```python
[
    {
        "code": "452",
        "name": "æ¶ˆé˜²å“¡",
        "description": "ç«ç½ã®äºˆé˜²ãƒ»è­¦æˆ’ãƒ»é®åœ§...",
        "similarity": 0.85
    },
    {...},  # Top-5
]
```

**å‡¦ç†ãƒ•ãƒ­ãƒ¼:**

```mermaid
graph LR
    A[ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›] --> B[Embedding API<br/>ãƒ™ã‚¯ãƒˆãƒ«åŒ–]
    B --> C[ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ™ã‚¯ãƒˆãƒ«<br/>1Ã—768]
    
    D[è·æ¥­ãƒ‡ãƒ¼ã‚¿] --> E[å…¨è·æ¥­ãƒ™ã‚¯ãƒˆãƒ«<br/>415Ã—768]
    
    C --> F[ã‚³ã‚µã‚¤ãƒ³é¡ä¼¼åº¦è¨ˆç®—]
    E --> F
    
    F --> G[é¡ä¼¼åº¦ãƒªã‚¹ãƒˆ<br/>415å€‹ã®æ•°å€¤]
    G --> H[ä¸Šä½5ä»¶æŠ½å‡º]
    H --> I[å€™è£œãƒªã‚¹ãƒˆè¿”å´]
```

**è©³ç´°ã‚³ãƒ¼ãƒ‰:**

```python
def search_candidates(self, user_input: str, top_k: int = 5):
    # EmbeddingsãŒæœªä½œæˆãªã‚‰ä½œæˆ
    if self.embeddings is None:
        self.create_embeddings()
    
    try:
        # ã‚¹ãƒ†ãƒƒãƒ—1: ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã‚’ãƒ™ã‚¯ãƒˆãƒ«åŒ–
        result = genai.embed_content(
            model=self.embedding_model,
            content=user_input,
            task_type="retrieval_query"  # æ¤œç´¢ã‚¯ã‚¨ãƒªç”¨
        )
        user_embedding = np.array([result['embedding']])
        # å½¢çŠ¶: (1, 768)
        
        # ã‚¹ãƒ†ãƒƒãƒ—2: ã‚³ã‚µã‚¤ãƒ³é¡ä¼¼åº¦ã‚’è¨ˆç®—
        similarities = cosine_similarity(
            user_embedding,      # (1, 768)
            self.embeddings      # (415, 768)
        )[0]
        # çµæœ: [0.85, 0.72, 0.68, ..., 0.23]  # 415å€‹ã®é¡ä¼¼åº¦
        
        # ã‚¹ãƒ†ãƒƒãƒ—3: é¡ä¼¼åº¦é †ã«ã‚½ãƒ¼ãƒˆï¼ˆé™é †ï¼‰
        top_indices = np.argsort(similarities)[::-1][:top_k]
        # çµæœ: [234, 412, 89, 156, 23]  # Top-5ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
        
        # ã‚¹ãƒ†ãƒƒãƒ—4: å€™è£œãƒªã‚¹ãƒˆã‚’ä½œæˆ
        candidates = []
        for idx in top_indices:
            candidates.append({
                "code": self.data.iloc[idx]["code"],
                "name": self.data.iloc[idx]["name"],
                "description": self.data.iloc[idx]["description"],
                "similarity": float(similarities[idx])
            })
        
        return candidates
        
    except Exception as e:
        raise RuntimeError(f"å€™è£œæ¤œç´¢ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}")
```

**ã‚³ã‚µã‚¤ãƒ³é¡ä¼¼åº¦ã®è¨ˆç®—æ–¹æ³•:**

```python
from sklearn.metrics.pairwise import cosine_similarity

# 2ã¤ã®ãƒ™ã‚¯ãƒˆãƒ«ã®æ–¹å‘ã®è¿‘ã•ã‚’-1ã€œ1ã§è¡¨ç¾
# 1.0  : å®Œå…¨ã«åŒã˜æ–¹å‘ï¼ˆæœ€ã‚‚é¡ä¼¼ï¼‰
# 0.0  : ç›´è§’ï¼ˆç„¡é–¢ä¿‚ï¼‰
# -1.0 : æ­£åå¯¾ã®æ–¹å‘

similarity = cosine_similarity(
    [[0.1, 0.2, 0.3]],  # ãƒ™ã‚¯ãƒˆãƒ«A
    [[0.1, 0.2, 0.3]]   # ãƒ™ã‚¯ãƒˆãƒ«B
)
# çµæœ: [[1.0]]  â† å®Œå…¨ä¸€è‡´
```

---

### 6. `decide_class` - LLMã«ã‚ˆã‚‹æœ€çµ‚åˆ¤å®š

**ã‚·ã‚°ãƒãƒãƒ£:**
```python
def decide_class(self, user_input: str, candidates: List[Dict]) -> Dict:
```

**ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:**
| ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ | å‹ | èª¬æ˜ |
|-----------|-----|------|
| `user_input` | str | ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è‡ªç”±è¨˜è¿°å…¥åŠ› |
| `candidates` | List[Dict] | æ¤œç´¢ã•ã‚ŒãŸå€™è£œãƒªã‚¹ãƒˆï¼ˆTop-5ï¼‰ |

**æˆ»ã‚Šå€¤:**
```python
{
    "code": "452",
    "name": "æ¶ˆé˜²å“¡",
    "reason": "ã€Œæ¶ˆé˜²è»Šã«ä¹—ã£ã¦ç«ã‚’æ¶ˆã™ã€ã¨ã„ã†è¨˜è¿°ãŒã€æ¶ˆé˜²å“¡ã®ä¸»è¦æ¥­å‹™ã§ã‚ã‚‹æ¶ˆç«æ´»å‹•ã«ç›´æ¥è©²å½“ã™ã‚‹ãŸã‚ã€‚"
}
```

**å‡¦ç†ãƒ•ãƒ­ãƒ¼:**

```mermaid
graph TB
    A[ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›] --> B[ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä½œæˆ]
    C[å€™è£œ5ä»¶] --> B
    
    B --> D[Gemini LLM<br/>gemini-2.5-flash]
    D --> E[JSONå½¢å¼ã§å›ç­”]
    
    E --> F{JSONè§£æ}
    F -->|æˆåŠŸ| G[çµæœè¿”å´]
    F -->|å¤±æ•—| H[ã‚¨ãƒ©ãƒ¼]
```

**ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä¾‹:**

```python
"""
ã‚ãªãŸã¯è·æ¥­åˆ†é¡ã®å°‚é–€å®¶ã§ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›ã¨ã€å€™è£œã¨ãªã‚‹è·æ¥­åˆ†é¡ãƒªã‚¹ãƒˆã‚’æ¯”è¼ƒã—ã€
æœ€ã‚‚é©åˆ‡ãªè·æ¥­åˆ†é¡ã‚’1ã¤é¸æŠã—ã¦ãã ã•ã„ã€‚

ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›ã€‘
æ¶ˆé˜²è»Šã«ä¹—ã£ã¦ç«ã‚’æ¶ˆã™ä»•äº‹

ã€å€™è£œã¨ãªã‚‹è·æ¥­åˆ†é¡ã€‘
- ã‚³ãƒ¼ãƒ‰: 452, åç§°: æ¶ˆé˜²å“¡, èª¬æ˜: ç«ç½ã®äºˆé˜²ãƒ»è­¦æˆ’ãƒ»é®åœ§ã€æ´ªæ°´ãƒ»ç«äº‹ãƒ»åœ°éœ‡ãªã©ã«ã‚ˆã‚‹è¢«å®³ã®è»½æ¸›ãªã©ã®ä»•äº‹...
- ã‚³ãƒ¼ãƒ‰: 451, åç§°: è­¦å¯Ÿå®˜, èª¬æ˜: æ²»å®‰ç¶­æŒã€çŠ¯ç½ªã®äºˆé˜²ãƒ»æœæŸ»...
- ã‚³ãƒ¼ãƒ‰: 450, åç§°: è‡ªè¡›å®˜, èª¬æ˜: å›½ã®é˜²è¡›ã€ç½å®³æ´¾é£...
- ã‚³ãƒ¼ãƒ‰: I42, åç§°: è‡ªå‹•è»Šé‹è»¢å¾“äº‹è€…, èª¬æ˜: ã‚¿ã‚¯ã‚·ãƒ¼é‹è»¢æ‰‹ã€ãƒã‚¹é‹è»¢æ‰‹...
- ã‚³ãƒ¼ãƒ‰: E52, åç§°: é£²é£Ÿç‰©èª¿ç†å¾“äº‹è€…, èª¬æ˜: èª¿ç†å¸«ã€ã‚³ãƒƒã‚¯...

ä¸Šè¨˜ã®å€™è£œã‹ã‚‰æœ€ã‚‚é©åˆ‡ãªè·æ¥­åˆ†é¡ã‚’1ã¤é¸æŠã—ã€
å¿…ãšä»¥ä¸‹ã®JSONå½¢å¼ã§å›ç­”ã—ã¦ãã ã•ã„ï¼š
{
  "code": "è·æ¥­ã‚³ãƒ¼ãƒ‰",
  "name": "è·æ¥­å",
  "reason": "ã“ã®è·æ¥­ã‚’é¸æŠã—ãŸç†ç”±ï¼ˆæ—¥æœ¬èªã§ç°¡æ½”ã«ï¼‰"
}
"""
```

**è©³ç´°ã‚³ãƒ¼ãƒ‰:**

```python
def decide_class(self, user_input: str, candidates: List[Dict]):
    # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä½œæˆ
    candidates_text = "\\n".join([
        f"- ã‚³ãƒ¼ãƒ‰: {c['code']}, åç§°: {c['name']}, èª¬æ˜: {c['description']}"
        for c in candidates
    ])
    
    prompt = f"""ã‚ãªãŸã¯è·æ¥­åˆ†é¡ã®å°‚é–€å®¶ã§ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›ã¨ã€å€™è£œã¨ãªã‚‹è·æ¥­åˆ†é¡ãƒªã‚¹ãƒˆã‚’æ¯”è¼ƒã—ã€æœ€ã‚‚é©åˆ‡ãªè·æ¥­åˆ†é¡ã‚’1ã¤é¸æŠã—ã¦ãã ã•ã„ã€‚

ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›ã€‘
{user_input}

ã€å€™è£œã¨ãªã‚‹è·æ¥­åˆ†é¡ã€‘
{candidates_text}

ä¸Šè¨˜ã®å€™è£œã‹ã‚‰æœ€ã‚‚é©åˆ‡ãªè·æ¥­åˆ†é¡ã‚’1ã¤é¸æŠã—ã€å¿…ãšä»¥ä¸‹ã®JSONå½¢å¼ã§å›ç­”ã—ã¦ãã ã•ã„ï¼š
{{
  "code": "è·æ¥­ã‚³ãƒ¼ãƒ‰",
  "name": "è·æ¥­å",
  "reason": "ã“ã®è·æ¥­ã‚’é¸æŠã—ãŸç†ç”±ï¼ˆæ—¥æœ¬èªã§ç°¡æ½”ã«ï¼‰"
}}"""
    
    try:
        # Gemini LLMã§åˆ¤å®š
        response = self.model.generate_content(
            prompt,
            generation_config=genai.GenerationConfig(
                response_mime_type="application/json",  # JSONå½¢å¼å¼·åˆ¶
                temperature=0.3  # å‰µé€ æ€§ã‚’æŠ‘ãˆã€æ±ºå®šè«–çš„ã«
            )
        )
        
        # JSONè§£æ
        result = json.loads(response.text)
        return result
        
    except Exception as e:
        raise RuntimeError(f"Gemini ã§ã®åˆ¤å®šä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}")
```

**JSON Modeã®åˆ©ç‚¹:**
- LLMãŒå¿…ãšJSONå½¢å¼ã§å›ç­”
- ãƒ‘ãƒ¼ã‚¹ ã‚¨ãƒ©ãƒ¼ã‚’æ¸›ã‚‰ã›ã‚‹
- æ§‹é€ åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿å–å¾—ãŒç¢ºå®Ÿ

---

### 7. `classify` - ãƒ¡ã‚¤ãƒ³å‡¦ç†ï¼ˆRAGã®å®Ÿè£…ï¼‰

**ã‚·ã‚°ãƒãƒãƒ£:**
```python
def classify(self, user_input: str) -> Dict:
```

**ã“ã‚ŒãŒRAGã®æ ¸å¿ƒï¼**

```python
def classify(self, user_input: str) -> Dict:
    """
    è·æ¥­åˆ†é¡åˆ¤å®šã®ãƒ¡ã‚¤ãƒ³å‡¦ç†ï¼ˆRAGå®Ÿè£…ï¼‰
    
    RAG = Retrieval + Augmented + Generation
    """
    
    # Step 1: Retrievalï¼ˆæ¤œç´¢ï¼‰
    # - ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã‚’ãƒ™ã‚¯ãƒˆãƒ«åŒ–
    # - 415ä»¶ã‹ã‚‰Top-5ã‚’æ¤œç´¢
    candidates = self.search_candidates(user_input, top_k=5)
    
    # Step 2: Augmented Generationï¼ˆæ‹¡å¼µç”Ÿæˆï¼‰
    # - æ¤œç´¢çµæœï¼ˆTop-5ï¼‰ã‚’ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«å«ã‚ã‚‹
    # - LLMãŒæ–‡è„ˆã‚’ç†è§£ã—ã¦æœ€çµ‚åˆ¤å®š
    result = self.decide_class(user_input, candidates)
    
    # çµæœã«å€™è£œãƒªã‚¹ãƒˆã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã‚’è¿½åŠ 
    result['candidates'] = candidates
    result['user_input'] = user_input
    
    return result
```

**RAGã®åˆ©ç‚¹:**

| ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ | å•é¡Œç‚¹ | RAGã«ã‚ˆã‚‹è§£æ±º |
|-----------|-------|-------------|
| LLMã®ã¿ | æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’çŸ¥ã‚‰ãªã„ | æ¤œç´¢ã§æœ€æ–°ãƒ‡ãƒ¼ã‚¿æä¾› |
| æ¤œç´¢ã®ã¿ | æ–‡è„ˆç†è§£ãŒå¼±ã„ | LLMãŒæ–‡è„ˆã‚’ç†è§£ |
| **RAG** | - | **æ¤œç´¢ + æ¨è«–ã®èåˆ** âœ¨ |

---

## ğŸ¯ å…¨ä½“ã®ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

### èµ·å‹•æ™‚ï¼ˆåˆå›ã®ã¿ï¼‰

```
main.pyèµ·å‹•
â†“
OccupationClassifier(csv_path="data/occupation.csv")
â†“
1. __init__: APIè¨­å®šã€ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰ï¼ˆ415ä»¶ï¼‰
â†“
2. create_embeddings: Embeddingä½œæˆ
   - 415è·æ¥­ Ã— Gemini Embedding API
   - ç´„3-5åˆ†ã‹ã‹ã‚‹
   - data/embeddings_cache.npy ã«ä¿å­˜
â†“
æº–å‚™å®Œäº†ï¼ˆãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯OKï¼‰
```

### 2å›ç›®ä»¥é™ã®èµ·å‹•

```
main.pyèµ·å‹•
â†“
OccupationClassifier(csv_path="data/occupation.csv")
â†“
1. __init__: APIè¨­å®šã€ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰ï¼ˆ415ä»¶ï¼‰
â†“
2. create_embeddings: ã‚­ãƒ£ãƒƒã‚·ãƒ¥èª­ã¿è¾¼ã¿
   - APIå‘¼ã³å‡ºã—ã‚¼ãƒ­ï¼
   - 1ç§’ä»¥å†…ã§å®Œäº†
â†“
æº–å‚™å®Œäº†ï¼ˆé«˜é€Ÿèµ·å‹•ï¼‰
```

### ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†

```
POST /api/classify
body: {"user_input": "æ¶ˆé˜²è»Šã«ä¹—ã£ã¦ç«ã‚’æ¶ˆã™ä»•äº‹"}
â†“
classifier.classify(user_input)
â†“
1. search_candidates:
   - ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã‚’ãƒ™ã‚¯ãƒˆãƒ«åŒ–ï¼ˆEmbedding API 1å›ï¼‰
   - ã‚³ã‚µã‚¤ãƒ³é¡ä¼¼åº¦è¨ˆç®—ï¼ˆPythonã€APIä¸è¦ï¼‰
   - Top-5æŠ½å‡º
â†“
2. decide_class:
   - ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä½œæˆï¼ˆå€™è£œ5ä»¶å«ã‚ã‚‹ï¼‰
   - Gemini LLMåˆ¤å®šï¼ˆGenerative API 1å›ï¼‰
   - JSONè§£æ
â†“
çµæœè¿”å´:
{
  "code": "452",
  "name": "æ¶ˆé˜²å“¡",
  "reason": "...",
  "candidates": [{...}, {...}, ...],
  "user_input": "æ¶ˆé˜²è»Šã«ä¹—ã£ã¦ç«ã‚’æ¶ˆã™ä»•äº‹"
}
```

---

## ğŸ’¡ è¨­è¨ˆã®å·¥å¤«

### 1. ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³

**ãªãœï¼Ÿ**
- Embeddingãƒ‡ãƒ¼ã‚¿ï¼ˆç´„1.3MBï¼‰ã‚’1å›ã ã‘ãƒ¡ãƒ¢ãƒªã«ä¿æŒ
- è¤‡æ•°ãƒªã‚¯ã‚¨ã‚¹ãƒˆã§åŒã˜ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å†åˆ©ç”¨

### 2. Embeddingã‚­ãƒ£ãƒƒã‚·ãƒ¥

**ãªãœï¼Ÿ**
- Podå†èµ·å‹•ã®ãŸã³ã«415å›ã®APIå‘¼ã³å‡ºã—ã¯éåŠ¹ç‡
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã§0å›ã«å‰Šæ¸›ï¼ˆã‚¯ã‚©ãƒ¼ã‚¿ç¯€ç´„ï¼‰

### 3. ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯

**ãªãœï¼Ÿ**
- CSVä¸è¦ã§ãƒ†ã‚¹ãƒˆå¯èƒ½
- ãƒ‡ãƒ—ãƒ­ã‚¤å¤±æ•—æ™‚ã®ä¿é™º
- ãƒ‡ãƒ¢ç’°å¢ƒã§ä¾¿åˆ©

### 4. RAGã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

**ãªãœï¼Ÿ**
- æ¤œç´¢ã ã‘: ç²¾åº¦ä½ã„
- LLMã ã‘: é…ã„ã€ã‚³ã‚¹ãƒˆé«˜ã„
- **RAG**: é«˜é€Ÿ + é«˜ç²¾åº¦ + ä½ã‚³ã‚¹ãƒˆ

---

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹

### APIå‘¼ã³å‡ºã—å›æ•°

| æ“ä½œ | å›æ•° |
|-----|------|
| åˆå›èµ·å‹•ï¼ˆEmbeddingä½œæˆï¼‰ | 415å› |
| 2å›ç›®ä»¥é™èµ·å‹•ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼‰ | **0å›** |
| 1å›ã®åˆ†é¡ãƒªã‚¯ã‚¨ã‚¹ãƒˆ | 2å› |

### å¿œç­”æ™‚é–“ï¼ˆç›®å®‰ï¼‰

| å‡¦ç† | æ™‚é–“ |
|-----|------|
| åˆå›èµ·å‹•ï¼ˆEmbeddingä½œæˆï¼‰ | 3-5åˆ† |
| 2å›ç›®ä»¥é™èµ·å‹• | 1ç§’ä»¥ä¸‹ |
| classifyï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›1å›ï¼‰ | 2-3ç§’ |

---

## ğŸ”§ ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒã‚¤ãƒ³ãƒˆ

### Top-Kå€™è£œæ•°ã®å¤‰æ›´

```python
# ç¾åœ¨: Top-5
candidates = self.search_candidates(user_input, top_k=5)

# ã‚ˆã‚Šå¤šãã®å€™è£œã‚’æ¤œè¨
candidates = self.search_candidates(user_input, top_k=10)
```

### LLMã®æ¸©åº¦èª¿æ•´

```python
# ç¾åœ¨: temperature=0.3ï¼ˆæ±ºå®šè«–çš„ï¼‰
generation_config=genai.GenerationConfig(
    response_mime_type="application/json",
    temperature=0.3
)

# ã‚ˆã‚Šå‰µé€ çš„ã«
temperature=0.7
```

### ãƒ¢ãƒ‡ãƒ«ã®å¤‰æ›´

```python
# ç¾åœ¨
self.embedding_model = "models/text-embedding-004"
self.llm_model = "models/gemini-2.5-flash"

# ã‚ˆã‚Šé«˜æ€§èƒ½ãªãƒ¢ãƒ‡ãƒ«
self.llm_model = "models/gemini-2.5-pro"
```

---

## ğŸ› ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### Q: "Embeddingsã¯æ—¢ã«ä½œæˆæ¸ˆã¿ã§ã™"ã¨è¡¨ç¤ºã•ã‚Œã‚‹ãŒå¤ã„ãƒ‡ãƒ¼ã‚¿ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹

**åŸå› :** ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ•ã‚¡ã‚¤ãƒ«ãŒå¤ã„

**è§£æ±º:**
```python
# ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å¼·åˆ¶å†ä½œæˆ
classifier.create_embeddings(force_recreate=True)

# ã¾ãŸã¯ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
rm data/embeddings_cache.npy
```

### Q: ã‚¯ã‚©ãƒ¼ã‚¿è¶…éã‚¨ãƒ©ãƒ¼

**åŸå› :** Gemini APIã®åˆ¶é™ï¼ˆ20ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/æ—¥ï¼‰

**è§£æ±º:**
1. 24æ™‚é–“å¾…ã¤
2. Embeddingã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ´»ç”¨ï¼ˆPodå†èµ·å‹•ã§ã‚‚APIä¸è¦ï¼‰
3. æœ‰æ–™ãƒ—ãƒ©ãƒ³ã«ç§»è¡Œ

### Q: æ¤œç´¢çµæœã®ç²¾åº¦ãŒä½ã„

**åŸå› :**
- Embeddingã®å“è³ª
- ãƒ‡ãƒ¼ã‚¿ã®èª¬æ˜æ–‡ãŒä¸ååˆ†

**è§£æ±º:**
1. ãƒ‡ãƒ¼ã‚¿ã®èª¬æ˜æ–‡ã‚’å……å®Ÿã•ã›ã‚‹
2. Top-Kæ•°ã‚’å¢—ã‚„ã™ï¼ˆ5 â†’ 10ï¼‰
3. ã‚ˆã‚Šæ–°ã—ã„Embeddingãƒ¢ãƒ‡ãƒ«ã‚’è©¦ã™

---

## ğŸ“š ã¾ã¨ã‚

**classifier.pyã®å½¹å‰²:**

1. **ãƒ‡ãƒ¼ã‚¿ç®¡ç†**: CSV or ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿
2. **Embeddingä½œæˆ**: Gemini Embedding API
3. **ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†**: APIå‘¼ã³å‡ºã—å‰Šæ¸›
4. **é¡ä¼¼åº¦æ¤œç´¢**: ã‚³ã‚µã‚¤ãƒ³é¡ä¼¼åº¦ã§Top-KæŠ½å‡º
5. **LLMåˆ¤å®š**: Gemini Generativeã§AIæ¨è«–
6. **RAGå®Ÿè£…**: Retrieval + Generationçµ±åˆ

**ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒRAGã‚·ã‚¹ãƒ†ãƒ ã®å¿ƒè‡“éƒ¨ã§ã™ï¼**
